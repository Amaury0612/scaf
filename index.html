<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nova Explorer | Simulation Interstellaire</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --ui-blue: #00f2ff;
            --ui-orange: #ffaa00;
            --bg-dark: #000205;
        }

        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            background-color: var(--bg-dark);
            color: var(--ui-blue);
            font-family: 'JetBrains Mono', monospace;
        }

        #canvas-container {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 1;
        }

        /* --- HUD STYLING --- */
        #hud {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 30px;
            box-sizing: border-box;
            border: 2px solid rgba(0, 242, 255, 0.1);
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .hud-bottom { display: flex; justify-content: space-between; align-items: flex-end; }

        .stat-group {
            background: rgba(0, 10, 20, 0.6);
            border-left: 3px solid var(--ui-blue);
            padding: 15px;
            backdrop-filter: blur(5px);
        }

        .label { font-size: 10px; opacity: 0.7; text-transform: uppercase; }
        .value { font-family: 'Orbitron', sans-serif; font-size: 18px; color: #fff; }

        .crosshair {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 40px; height: 40px;
            border: 1px solid rgba(0, 242, 255, 0.4);
            border-radius: 50%;
        }
        .crosshair::before, .crosshair::after {
            content: ''; position: absolute; background: var(--ui-blue);
        }
        .crosshair::before { width: 10px; height: 1px; top: 50%; left: -15px; }
        .crosshair::after { width: 10px; height: 1px; top: 50%; right: -15px; }

        .velocity-bar {
            width: 200px; height: 4px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 8px;
            position: relative;
        }
        #velocity-fill {
            height: 100%; width: 0%;
            background: var(--ui-blue);
            box-shadow: 0 0 10px var(--ui-blue);
        }

        #boot-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease;
        }

        .loader {
            width: 300px;
            height: 2px;
            background: #111;
            margin-top: 20px;
            position: relative;
        }
        .loader-fill {
            position: absolute;
            width: 0%; height: 100%;
            background: var(--ui-blue);
            animation: load 3s forwards;
        }

        @keyframes load { 0% { width: 0%; } 100% { width: 100%; } }

        .scanline {
            width: 100%; height: 100%;
            position: absolute; top: 0; left: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            pointer-events: none; z-index: 20;
        }
    </style>
</head>
<body>

    <div id="boot-screen">
        <h1 style="font-family: 'Orbitron'; letter-spacing: 10px;">NOVA EXPLORER</h1>
        <div class="loader"><div class="loader-fill"></div></div>
        <p style="margin-top: 20px; font-size: 12px; opacity: 0.5;">INITIALISATION DES SYSTÈMES DE NAVIGATION...</p>
    </div>

    <div class="scanline"></div>

    <div id="hud">
        <div class="hud-top">
            <div class="stat-group">
                <div class="label">Vitesse de Croisière</div>
                <div class="value" id="ui-speed">0.00 km/s</div>
                <div class="velocity-bar"><div id="velocity-fill"></div></div>
            </div>
            <div class="stat-group" style="text-align: right;">
                <div class="label">Coordonnées Galactiques</div>
                <div class="value" id="ui-coords">X: 0.00 Y: 0.00 Z: 0.00</div>
            </div>
        </div>

        <div class="crosshair"></div>

        <div class="hud-bottom">
            <div class="stat-group">
                <div class="label">Système Actuel</div>
                <div class="value">NOVA-PRIME 01</div>
            </div>
            <div class="stat-group" style="text-align: right; border-left: none; border-right: 3px solid var(--ui-orange);">
                <div class="label" style="color: var(--ui-orange);">Intégrité Structurelle</div>
                <div class="value">100% [STABLE]</div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        /**
         * MOTEUR DE SIMULATION NOVA EXPLORER
         * Développé pour une immersion maximale.
         */

        // --- CONFIGURATION ---
        let scene, camera, renderer, clock;
        let starfield, sun, planets = [];
        let shipPhysics = {
            velocity: new THREE.Vector3(),
            rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
            thrust: 0.005,
            rotationSpeed: 0.02,
            maxSpeed: 2.0,
            friction: 0.985
        };

        const keys = {};

        // --- INITIALISATION ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // Environnement
            createUniverse();
            createSolarSystem();

            // Position initiale
            camera.position.set(0, 0, 500);

            // Event Listeners
            window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);

            // Démarrage après loading fictif
            setTimeout(() => {
                document.getElementById('boot-screen').style.opacity = '0';
                setTimeout(() => document.getElementById('boot-screen').remove(), 1000);
            }, 3000);

            animate();
        }

        // --- GÉNÉRATION DU MONDE ---
        function createUniverse() {
            // Fond d'étoiles (Milky Way)
            const starGeo = new THREE.BufferGeometry();
            const starCoords = [];
            for (let i = 0; i < 15000; i++) {
                const x = (Math.random() - 0.5) * 20000;
                const y = (Math.random() - 0.5) * 20000;
                const z = (Math.random() - 0.5) * 20000;
                starCoords.push(x, y, z);
            }
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
            const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.8 });
            starfield = new THREE.Points(starGeo, starMat);
            scene.add(starfield);

            // Lumière d'ambiance cosmique
            scene.add(new THREE.AmbientLight(0x050510));
        }

        function createSolarSystem() {
            // LE SOLEIL (Sun)
            const sunGeo = new THREE.SphereGeometry(100, 64, 64);
            const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
            sun = new THREE.Mesh(sunGeo, sunMat);
            scene.add(sun);

            // Halo Solaire (Lumière ponctuelle massive)
            const sunLight = new THREE.PointLight(0xffffff, 2, 20000);
            scene.add(sunLight);

            // PLANÈTE 1 : TERRA NOVA
            createPlanet(1200, 30, 0x0077ff, true); // Bleue avec anneaux
            
            // PLANÈTE 2 : MAGMA
            createPlanet(2500, 45, 0xff4400, false);
            
            // PLANÈTE 3 : FROST
            createPlanet(4500, 60, 0xaabbff, true);
        }

        function createPlanet(distance, size, color, hasRings) {
            const group = new THREE.Group();
            
            // Corps planétaire
            const geo = new THREE.SphereGeometry(size, 64, 64);
            const mat = new THREE.MeshPhongMaterial({ 
                color: color, 
                shininess: 20,
                bumpScale: 1
            });
            const mesh = new THREE.Mesh(geo, mat);
            group.add(mesh);

            // Anneaux si nécessaire
            if (hasRings) {
                const ringGeo = new THREE.RingGeometry(size * 1.5, size * 2.5, 64);
                const ringMat = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    side: THREE.DoubleSide, 
                    transparent: true, 
                    opacity: 0.3 
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = Math.PI / 2.5;
                group.add(ring);
            }

            // Orbite initiale aléatoire
            const angle = Math.random() * Math.PI * 2;
            group.position.x = Math.cos(angle) * distance;
            group.position.z = Math.sin(angle) * distance;

            scene.add(group);
            planets.push({
                mesh: group,
                distance: distance,
                speed: 0.05 / (distance / 500),
                angle: angle
            });
        }

        // --- LOGIQUE DE PILOTAGE ---
        function updatePhysics() {
            const delta = clock.getDelta();

            // ROTATION (Roulis / Lacet / Tangage)
            if (keys['a']) camera.rotation.z += shipPhysics.rotationSpeed;
            if (keys['e']) camera.rotation.z -= shipPhysics.rotationSpeed;
            
            // AVANCER / RECULER (Z/S)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);

            if (keys['z']) {
                shipPhysics.velocity.add(direction.clone().multiplyScalar(shipPhysics.thrust));
            }
            if (keys['s']) {
                shipPhysics.velocity.add(direction.clone().multiplyScalar(-shipPhysics.thrust));
            }

            // MONTER / DESCENDRE (Shift/Ctrl)
            const upVector = new THREE.Vector3(0, 1, 0);
            upVector.applyQuaternion(camera.quaternion);
            if (keys['shift']) shipPhysics.velocity.add(upVector.clone().multiplyScalar(shipPhysics.thrust));
            if (keys['control']) shipPhysics.velocity.add(upVector.clone().multiplyScalar(-shipPhysics.thrust));

            // Friction & Limites
            shipPhysics.velocity.multiplyScalar(shipPhysics.friction);
            if (shipPhysics.velocity.length() > shipPhysics.maxSpeed) {
                shipPhysics.velocity.setLength(shipPhysics.maxSpeed);
            }

            // Application du mouvement
            camera.position.add(shipPhysics.velocity);

            // Mise à jour de l'UI
            updateHUD();
        }

        function onMouseMove(e) {
            // Rotation avec la souris (Tangage / Lacet)
            const x = (e.clientX / window.innerWidth) - 0.5;
            const y = (e.clientY / window.innerHeight) - 0.5;

            // Sensibilité du manche à balai
            camera.rotation.y -= x * 0.05;
            camera.rotation.x -= y * 0.05;
        }

        function updateHUD() {
            const speed = (shipPhysics.velocity.length() * 450).toFixed(2);
            document.getElementById('ui-speed').innerText = `${speed} km/s`;
            document.getElementById('velocity-fill').style.width = `${(speed / 1000) * 100}%`;
            
            const pos = camera.position;
            document.getElementById('ui-coords').innerText = 
                `X: ${(pos.x/10).toFixed(1)} Y: ${(pos.y/10).toFixed(1)} Z: ${(pos.z/10).toFixed(1)}`;
        }

        // --- ANIMATION FRAME ---
        function animate() {
            requestAnimationFrame(animate);

            // Mouvement des planètes
            planets.forEach(p => {
                p.angle += p.speed * 0.01;
                p.mesh.position.x = Math.cos(p.angle) * p.distance;
                p.mesh.position.z = Math.sin(p.angle) * p.distance;
                p.mesh.rotation.y += 0.005;
            });

            // Rotation du soleil
            if (sun) sun.rotation.y += 0.001;

            updatePhysics();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // INIT
        window.onload = init;
    </script>
</body>
</html>
